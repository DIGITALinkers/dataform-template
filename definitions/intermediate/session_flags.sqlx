config {
    type: "incremental",
    schema: "intermediate", 
    name: "session_flags",
    description: "Table of flattened GA4 events, enriched with session-level flags",
    uniqueKey: ["unique_session_id"],
    bigquery: {
        partitionBy: "session_date",
        updatePartitionFilter: "session_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)"
    },
    tags: ['flags']
}

pre_operations {
-- before the main query runs, we check whether we are in an incremental run (or in a full refresh)
-- if it's an incremental run, we start by deleting the data for the past 3 days
-- that will then be inserted again by the incremental run.
  ${
    when(incremental(),
      `delete from ${self()} where date_partition >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 DAY)`
      )
  }
}

/******************************************************************
-- Step 1 : get all events + session flags that will be used ------
-- downstream to track behaviour ----------------------------------
******************************************************************/

WITH event_data AS 
(
SELECT *
FROM ${ref('flat_events')}
WHERE 1=1

    -- for incremental runs, we only want to run the query on the past 3 days. For that we use the incremental() built-in function
    -- combined with the when() built-in function and with a variable "incremental_days_refresh", defined in dataform.json.
    
    ${when(incremental(),
              `and date_partition >= DATE_SUB(CURRENT_DATE(), INTERVAL CAST(${dataform.projectConfig.vars.incremental_days_refresh} AS INT64) DAY)`
       )}
)

, flags AS 
(
SELECT 
    unique_session_id, 

    -- ======================
    -- Session timing (first value = session start)
    -- ======================
    MIN(date_partition) AS session_date,
    MIN(event_timestamp) AS session_start_timestamp,
    MAX(event_timestamp) AS session_end_timestamp,
    
    -- ======================
    -- Dimensions (first value in session)
    -- ======================
    ARRAY_AGG(device.web_info.browser IGNORE NULLS ORDER BY event_timestamp LIMIT 1)[OFFSET(0)] AS browser,
    ARRAY_AGG(device.category IGNORE NULLS ORDER BY event_timestamp LIMIT 1)[OFFSET(0)] AS device_category,
    ARRAY_AGG(device.operating_system IGNORE NULLS ORDER BY event_timestamp LIMIT 1)[OFFSET(0)] AS operating_system,
    ARRAY_AGG(geo.country IGNORE NULLS ORDER BY event_timestamp LIMIT 1)[OFFSET(0)] AS country,
    ARRAY_AGG(geo.region IGNORE NULLS ORDER BY event_timestamp LIMIT 1)[OFFSET(0)] AS region,
    ARRAY_AGG(geo.city IGNORE NULLS ORDER BY event_timestamp LIMIT 1)[OFFSET(0)] AS city,
    
    -- Traffic source (first value)
    ${helpers.channelGrouping(
    'ARRAY_AGG(traffic_source.source IGNORE NULLS ORDER BY event_timestamp LIMIT 1)[OFFSET(0)]',
    'ARRAY_AGG(traffic_source.medium IGNORE NULLS ORDER BY event_timestamp LIMIT 1)[OFFSET(0)]',
    'ARRAY_AGG(traffic_source.name IGNORE NULLS ORDER BY event_timestamp LIMIT 1)[OFFSET(0)]'
    )} AS channel_grouping,
    
    -- Landing page (first page_location)
    ARRAY_AGG(epk_page_location IGNORE NULLS ORDER BY event_timestamp LIMIT 1)[OFFSET(0)] AS landing_page,
    
    -- ======================
    -- Session-level flags & event counts 
    -- ======================

    ${helpers.eventFlagColumns(constants.trackedEventNames)},
    ${helpers.eventParamFlagColumns(constants.customEventParamFlags)},
    ${helpers.numericFlagColumns(constants.numericThresholdFlags)},
    ${helpers.compositeFlagColumns(constants.compositeEventFlags)}

FROM event_data 
GROUP BY 
    unique_session_id
)

SELECT * 
FROM flags